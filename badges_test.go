package devflow

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestGetBadgeColor(t *testing.T) {
	tests := []struct {
		typ   string
		value string
		want  string
	}{
		{"license", "MIT", "#007acc"},
		{"go", "1.20", "#007acc"},
		{"tests", "Passing", "#4c1"},
		{"tests", "Failed", "#e05d44"},
		{"coverage", "85", "#4c1"},
		{"coverage", "65", "#dfb317"},
		{"coverage", "30", "#fe7d37"},
		{"coverage", "0", "#e05d44"},
		{"race", "Clean", "#4c1"},
		{"race", "Detected", "#e05d44"},
		{"vet", "OK", "#4c1"},
		{"vet", "Issues", "#e05d44"},
	}

	for _, tt := range tests {
		got := getBadgeColor(tt.typ, tt.value)
		if got != tt.want {
			t.Errorf("getBadgeColor(%q, %q) = %q, want %q", tt.typ, tt.value, got, tt.want)
		}
	}
}

func TestGetGoVersion(t *testing.T) {
	version := getGoVersion()
	if version == "" {
		t.Error("Expected non-empty go version")
	}
}

func TestBadgeMarkdown_Default(t *testing.T) {
	// Provide an arg so NewBadges doesn't return nil
	h := NewBadges("output_svgfile:docs/img/custom.svg")
	if h == nil {
		t.Fatal("NewBadges returned nil")
	}
	if err := h.Err(); err != nil {
		t.Fatalf("NewBadges returned error: %v", err)
	}

	want := `<a href="docs/img/custom.svg"><img src="docs/img/custom.svg" alt="Project Badges" title="Generated by devflow from ` + DevFlowRepository + `"></a>`
	got := h.BadgeMarkdown()
	if got != want {
		t.Fatalf("unexpected markdown:\n got: %s\nwant: %s", got, want)
	}
}

func TestBadgeMarkdown_DefaultHandlerValue(t *testing.T) {
	// When created with no special args the default outputFile should be used
	h := NewBadges("dummy")
	if h == nil {
		t.Fatal("NewBadges returned nil")
	}
	if err := h.Err(); err != nil {
		t.Fatalf("NewBadges returned error: %v", err)
	}

	want := `<a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="Generated by devflow from ` + DevFlowRepository + `"></a>`
	got := h.BadgeMarkdown()
	if got != want {
		t.Fatalf("unexpected markdown:\n got: %s\nwant: %s", got, want)
	}
}

func TestGenerate_MatchesExpected(t *testing.T) {
	// args designed to produce the expected.svg in testdata
	args := []string{
		"License:MIT:#007acc",
		"Go:1.24.4:#00ADD8",
		"Tests:Passing:#4c1",
		"Coverage:73%:#dfb317",
		"Race:Clean:#4c1",
		"Vet:OK:#4c1",
	}

	h := NewBadges(args...)
	if h == nil {
		t.Fatalf("NewBadges returned nil")
	}
	if err := h.Err(); err != nil {
		t.Fatalf("NewBadges error: %v", err)
	}

	svgBytes, _, err := h.GenerateSVG()
	if err != nil {
		t.Fatalf("GenerateSVG error: %v", err)
	}
	svg := string(svgBytes)

	wantPath := filepath.Join("testdata", "expected.svg")
	wantBytes, rerr := os.ReadFile(wantPath)
	if rerr != nil {
		t.Fatalf("read expected file: %v", rerr)
	}

	got := strings.TrimSpace(svg)
	want := strings.TrimSpace(string(wantBytes))

	if got != want {
		t.Fatalf("generated SVG differs from expected\n--- got ---\n%s\n--- want ---\n%s", got, want)
	}
}

// TestBuildBadges_SectionArgsOrder ensures BuildBadges returns the four
// arguments required by SectionUpdate in the exact order:
// [sectionID, afterLine, content, readmeFile]
func TestBuildBadges_SectionArgsOrder(t *testing.T) {
	tmp := t.TempDir()
	out := filepath.Join(tmp, "badges.svg")

	// create handler with explicit output and readme file settings and one badge
	h := NewBadges("output_svgfile:"+out, "readmefile:MYREADME.md", "License:MIT:#007acc")
	if h == nil {
		t.Fatal("NewBadges returned nil")
	}
	if err := h.Err(); err != nil {
		t.Fatalf("handler init error: %v", err)
	}

	args, err := h.BuildBadges()
	if err != nil {
		t.Fatalf("BuildBadges error: %v", err)
	}

	if len(args) != 4 {
		t.Fatalf("expected 4 args, got %d: %#v", len(args), args)
	}

	// Check order
	if args[0] != "BADGES_SECTION" {
		t.Errorf("sectionID order mismatch: want BADGES_SECTION, got %q", args[0])
	}
	if args[1] != "1" {
		t.Errorf("afterLine order mismatch: want \"1\", got %q", args[1])
	}
	if args[2] != h.BadgeMarkdown() {
		t.Errorf("content mismatch: want BadgeMarkdown(), got %q", args[2])
	}
	if args[3] != "MYREADME.md" {
		t.Errorf("readmeFile mismatch: want MYREADME.md, got %q", args[3])
	}

	// Ensure output file was written and looks like an SVG
	info, err := os.Stat(out)
	if err != nil {
		t.Fatalf("expected output file %s to exist: %v", out, err)
	}
	if info.Size() == 0 {
		t.Fatalf("output file %s is empty", out)
	}
}

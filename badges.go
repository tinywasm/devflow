package devflow

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

// Badges is responsible for creating and managing a collection of badges.
// It handles parsing input arguments, generating the SVG image, and preparing
// the necessary markdown to embed the badges in a file.
type Badges struct {
	args       []string
	outputFile string
	readmeFile string
	// stored initialization/parsing error; methods must check this
	err error
	// Go handler
	goH *Go
	// defaults for section update
	sectionID string
	afterLine string
	// configuration (moved from package-level constants)
	svgHeight    int
	badgeHeight  int
	fontSize     int
	labelPadding int
	valuePadding int
	badgeSpacing int
	labelBg      string
	badgesInfo   string
	// separate text used in the svg comment/header (matches original bash script)
	svgInfo string
	log     func(...any)
}

// NewBadges creates and initializes a new Badges handler.
func NewBadges(args ...string) *Badges {
	// Create handler with defaults
	h := &Badges{
		outputFile:   "docs/img/badges.svg",
		svgHeight:    20,
		badgeHeight:  20,
		fontSize:     11,
		labelPadding: 6,
		valuePadding: 6,
		badgeSpacing: 5,
		labelBg:      "#6c757d",
		badgesInfo:   "Generated by badges package from github.com/cdvelop/devscripts",
		svgInfo:      "Generated by badges.sh from github.com/cdvelop/devscripts",
		log:          func(...any) {},
	}

	// Create a default Go handler.
	g, _ := NewGo(nil)
	h.goH = g

	// If the first argument is a directory, treat it as the current working directory.
	if len(args) > 0 {
		if fi, err := os.Stat(args[0]); err == nil && fi.IsDir() {
			gitPath := filepath.Join(args[0], ".git")
			if _, serr := os.Stat(gitPath); os.IsNotExist(serr) {
				h.err = fmt.Errorf("Git repository not found")
				return h
			}
			// remove the injected current-dir arg
			args = args[1:]
		}
	}

	if len(args) == 0 {
		h.err = fmt.Errorf("no badges specified, usage: badges.sh \"label:value:color\" \"label:value:color\"")
		return h
	}

	// assign args and process args to detect special commands (output_svgfile: and readmefile:)
	h.args = args
	// defaults
	h.readmeFile = "README.md"
	// default section values
	h.sectionID = "BADGES_SECTION"
	h.afterLine = "1"
	for _, a := range args {
		if strings.HasPrefix(a, "output_svgfile:") {
			h.outputFile = a[len("output_svgfile:"):]
			continue
		}
		if strings.HasPrefix(a, "readmefile:") {
			h.readmeFile = a[len("readmefile:"):]
			continue
		}
	}

	return h
}

// SetLog sets the logger function
func (h *Badges) SetLog(fn func(...any)) {
	if fn != nil {
		h.log = fn
		if h.goH != nil {
			h.goH.SetLog(fn)
		}
	}
}

// BuildBadges generates the SVG image, writes it to the specified output file,
// and returns a slice of strings intended for updating a markdown file.
func (h *Badges) BuildBadges() ([]string, error) {
	if h.err != nil {
		return nil, h.err
	}

	// First pass: collect parse errors/warnings like the bash implementation
	var errorMessages []string
	generatedBadgesCount := 0
	for _, p := range h.args {
		// skip special commands
		if strings.HasPrefix(p, "output_svgfile:") || strings.HasPrefix(p, "readmefile:") {
			continue
		}
		_, perr := parseBadge(p)
		if perr != nil {
			// special command sentinel
			if strings.Contains(perr.Error(), "special command") {
				continue
			}
			// Normalize messages to match the bash tests expectations
			if strings.Contains(perr.Error(), "invalid badge format") {
				errorMessages = append(errorMessages, fmt.Sprintf("Error: Invalid badge format: %s", p))
			} else if strings.Contains(perr.Error(), "empty fields in badge") {
				errorMessages = append(errorMessages, fmt.Sprintf("Error: Empty fields in badge: %s", p))
			} else {
				errorMessages = append(errorMessages, fmt.Sprintf("Error: %s", perr.Error()))
			}
			continue
		}
		generatedBadgesCount++
	}

	// Generate SVG
	svgBytes, _, genErr := h.GenerateSVG()

	// Print accumulated error messages
	if len(errorMessages) > 0 {
		for _, m := range errorMessages {
			h.log(m)
		}
	}

	if genErr != nil {
		// No valid badges case should match bash: print explicit message
		if generatedBadgesCount == 0 {
			h.log("Error: No valid badges to generate")
		}
		return nil, genErr
	}

	// ensure directory exists when writing file
	if err := os.MkdirAll(filepath.Dir(h.outputFile), 0o755); err != nil {
		return nil, fmt.Errorf("create output dir: %w", err)
	}

	// Check if file exists and content is the same (don't rewrite if identical)
	shouldWrite := true
	if existing, err := os.ReadFile(h.outputFile); err == nil {
		if bytes.Equal(existing, svgBytes) {
			shouldWrite = false
		}
	}

	if shouldWrite {
		if err := os.WriteFile(h.outputFile, svgBytes, 0o644); err != nil {
			return nil, fmt.Errorf("write svg file: %w", err)
		}
	}

	// Build the section args expected by SectionUpdate
	sectionContent := h.BadgeMarkdown()
	args := []string{h.sectionID, h.afterLine, sectionContent, h.readmeFile}
	return args, nil
}

// OutputFile returns the configured path for the output SVG file.
func (h *Badges) OutputFile() string {
	if h.err != nil {
		return ""
	}
	return h.outputFile
}

// ReadmeFile returns the configured path for the markdown file to be updated.
func (h *Badges) ReadmeFile() string {
	if h.err != nil {
		return ""
	}
	return h.readmeFile
}

// BadgeMarkdown generates the markdown snippet for embedding the badge image.
func (h *Badges) BadgeMarkdown() string {
	if h.err != nil {
		return ""
	}

	svgFile := h.outputFile
	return fmt.Sprintf(`<a href="%s"><img src="%s" alt="Project Badges" title="%s"></a>`,
		svgFile, svgFile, h.badgesInfo)
}

// Err returns any error that occurred during the initialization or processing
func (h *Badges) Err() error {
	return h.err
}

// GoHandler returns the internal Go handler
func (h *Badges) GoHandler() *Go {
	return h.goH
}

func getGoVersion() string {
	out, err := RunCommand("go", "version")
	if err != nil {
		return "unknown"
	}
	parts := strings.Fields(out)
	if len(parts) >= 3 {
		return strings.TrimPrefix(parts[2], "go")
	}
	return "unknown"
}

func getBadgeColor(typ, value string) string {
	switch typ {
	case "license", "go":
		return "#007acc"
	case "tests":
		if value == "Passing" {
			return "#4c1"
		}
		return "#e05d44"
	case "coverage":
		val, _ := strconv.ParseFloat(value, 64)
		if val >= 80 {
			return "#4c1"
		} else if val >= 60 {
			return "#dfb317"
		} else if val > 0 {
			return "#fe7d37"
		}
		return "#e05d44"
	case "race":
		if value == "Clean" {
			return "#4c1"
		}
		return "#e05d44"
	case "vet":
		if value == "OK" {
			return "#4c1"
		}
		return "#e05d44"
	}
	return "#007acc"
}

func getModuleName(dir string) (string, error) {
	f, err := os.Open(filepath.Join(dir, "go.mod"))
	if err != nil {
		return "", err
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasPrefix(line, "module ") {
			return strings.TrimPrefix(line, "module "), nil
		}
	}
	return "", fmt.Errorf("module name not found in go.mod")
}

func checkFileExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

func (h *Badges) updateBadges(readmeFile, licenseType, goVer, testStatus, coveragePercent, raceStatus, vetStatus string, quiet bool) error {
	// Colors
	licenseColor := getBadgeColor("license", licenseType)
	goColor := getBadgeColor("go", goVer)
	testColor := getBadgeColor("tests", testStatus)
	coverageColor := getBadgeColor("coverage", coveragePercent)
	raceColor := getBadgeColor("race", raceStatus)
	vetColor := getBadgeColor("vet", vetStatus)

	badgeArgs := []string{
		"readmefile:" + readmeFile,
		fmt.Sprintf("License:%s:%s", licenseType, licenseColor),
		fmt.Sprintf("Go:%s:%s", goVer, goColor),
		fmt.Sprintf("Tests:%s:%s", testStatus, testColor),
		fmt.Sprintf("Coverage:%s%%:%s", coveragePercent, coverageColor),
		fmt.Sprintf("Race:%s:%s", raceStatus, raceColor),
		fmt.Sprintf("Vet:%s:%s", vetStatus, vetColor),
	}

	bh := NewBadges(badgeArgs...)
	bh.SetLog(h.log)
	sectionArgs, err := bh.BuildBadges()
	if err != nil {
		return fmt.Errorf("error building badges: %w", err)
	}

	if len(sectionArgs) >= 4 {
		sectionID := sectionArgs[0]
		afterLine := sectionArgs[1]
		content := sectionArgs[2]
		readmeFile := sectionArgs[3]

		m := NewMarkDown(".", ".", func(name string, data []byte) error {
			return os.WriteFile(name, data, 0644)
		})
		m.InputPath(readmeFile, func(name string) ([]byte, error) {
			return os.ReadFile(name)
		})

		if err := m.UpdateSection(sectionID, content, afterLine); err != nil {
			return fmt.Errorf("error updating README with markdown handler: %w", err)
		}

		if !quiet {
			h.log(fmt.Sprintf("Updated section %s in %s", sectionID, readmeFile))
		}
	}

	return nil
}

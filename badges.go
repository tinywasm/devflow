package devflow

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

// Badges is responsible for creating and managing a collection of badges.
// It handles parsing input arguments, generating the SVG image, and preparing
// the necessary markdown to embed the badges in a file.
//
// The handler is configured using a series of string arguments, where each argument
// defines a badge in the "label:value:color" format.
//
// Special commands can be passed as arguments to control the output:
//   - "output_svgfile:path/to/your.svg": Specifies the output file for the SVG image.
//   - "readmefile:path/to/your/README.md": Specifies the markdown file to be updated.
type Badges struct {
	args       []string
	outputFile string
	readmeFile string
	// stored initialization/parsing error; methods must check this
	err error
	// Go handler
	goH *Go
	// defaults for section update
	sectionID string
	afterLine string
	// configuration (moved from package-level constants)
	svgHeight    int
	badgeHeight  int
	fontSize     int
	labelPadding int
	valuePadding int
	badgeSpacing int
	labelBg      string
	badgesInfo   string
	// separate text used in the svg comment/header (matches original bash script)
	svgInfo string
}

// NewBadges creates and initializes a new Badges.
//
// It takes a variadic slice of strings as input. Each string can be a badge
// definition ("label:value:color") or a special command.
//
// Example:
//
//	handler := NewBadges(
//	  "Go:1.18:#007d9c",
//	  "Tests:Passing:#4c1",
//	  "output_svgfile:docs/badges.svg",
//	)
func NewBadges(args ...string) *Badges {
	// Create handler with defaults
	h := &Badges{
		outputFile:   "docs/img/badges.svg",
		svgHeight:    20,
		badgeHeight:  20,
		fontSize:     11,
		labelPadding: 6,
		valuePadding: 6,
		badgeSpacing: 5,
		labelBg:      "#6c757d",
		badgesInfo:   "Generated by badges package from github.com/cdvelop/devscripts",
		svgInfo:      "Generated by badges.sh from github.com/cdvelop/devscripts",
		// Default Go handler (can be overridden if needed, or initialized differently)
		// For now we initialize with nil git handler as we don't strictly need it for GoVersion
		// unless we want to enforce full initialization.
	}

	// Create a default Go handler. We ignore error here since it's just a helper
	// and Badges is primarily string based.
	// However, if we want strictness, we could handle error.
	// For this request, we just add it to the struct.
	// Assuming NewGo requires a Git handler, maybe we should just create one manually or
	// pass nil if NewGo allows it. NewGo verifies 'go version' command.
	g, _ := NewGo(nil)
	h.goH = g

	// If the first argument is a directory (injected by gocurrentdir.sh),
	// treat it as the current working directory: verify .git exists there
	// and strip the injected directory before further processing.
	if len(args) > 0 {
		if fi, err := os.Stat(args[0]); err == nil && fi.IsDir() {
			gitPath := filepath.Join(args[0], ".git")
			if _, serr := os.Stat(gitPath); os.IsNotExist(serr) {
				h.err = fmt.Errorf("Git repository not found")
				return h
			}
			// remove the injected current-dir arg
			args = args[1:]
		}
	}

	if len(args) == 0 {
		// store error in handler containing the same user-facing messages
		// used by the original bash implementation so tests depending on
		// exact substrings continue to pass.
		h.err = fmt.Errorf("No badges specified\nUsage: badges.sh \"label:value:color\" \"label:value:color\" ...")
		return h
	}

	// assign args and process args to detect special commands (output_svgfile: and readmefile:)
	h.args = args
	// defaults
	h.readmeFile = "README.md"
	// default section values (private defaults)
	h.sectionID = "BADGES_SECTION"
	h.afterLine = "1"
	for _, a := range args {
		if strings.HasPrefix(a, "output_svgfile:") {
			h.outputFile = a[len("output_svgfile:"):]
			continue
		}
		if strings.HasPrefix(a, "readmefile:") {
			h.readmeFile = a[len("readmefile:"):]
			continue
		}
	}

	return h
}

// BuildBadges generates the SVG image, writes it to the specified output file,
// and returns a slice of strings intended for updating a markdown file.
//
// The returned slice contains the following elements in order:
// 1. sectionID: The ID of the markdown section to update.
// 2. afterLine: The line number after which the content should be inserted.
// 3. content: The markdown content to be inserted.
// 4. readmeFile: The path to the markdown file to be updated.
//
// This method centralizes the core logic of badge generation and file I/O.
func (h *Badges) BuildBadges() ([]string, error) {
	if h.err != nil {
		return nil, h.err
	}

	// First pass: collect parse errors/warnings like the bash implementation
	var errorMessages []string
	generatedBadgesCount := 0
	for _, p := range h.args {
		// skip special commands (already processed by NewBadgeHandler)
		if strings.HasPrefix(p, "output_svgfile:") || strings.HasPrefix(p, "readmefile:") {
			continue
		}
		_, perr := parseBadge(p)
		if perr != nil {
			// special command sentinel
			if strings.Contains(perr.Error(), "special command") {
				continue
			}
			// Normalize messages to match the bash tests expectations
			if strings.Contains(perr.Error(), "invalid badge format") {
				errorMessages = append(errorMessages, fmt.Sprintf("Error: Invalid badge format: %s", p))
			} else if strings.Contains(perr.Error(), "empty fields in badge") {
				errorMessages = append(errorMessages, fmt.Sprintf("Error: Empty fields in badge: %s", p))
			} else {
				errorMessages = append(errorMessages, fmt.Sprintf("Error: %s", perr.Error()))
			}
			continue
		}
		generatedBadgesCount++
	}

	// Generate SVG
	svgBytes, _, genErr := h.GenerateSVG()

	// Print accumulated error messages (tests look for these substrings)
	if len(errorMessages) > 0 {
		for _, m := range errorMessages {
			// print to stdout so tests can capture it
			println(m)
		}
	}

	if genErr != nil {
		// No valid badges case should match bash: print explicit message
		if generatedBadgesCount == 0 {
			println("Error: No valid badges to generate")
		}
		return nil, genErr
	}

	// ensure directory exists when writing file
	if err := os.MkdirAll(filepath.Dir(h.outputFile), 0o755); err != nil {
		return nil, fmt.Errorf("create output dir: %w", err)
	}

	// Check if file exists and content is the same (don't rewrite if identical)
	shouldWrite := true
	if existing, err := os.ReadFile(h.outputFile); err == nil {
		if bytes.Equal(existing, svgBytes) {
			shouldWrite = false
		}
	}

	if shouldWrite {
		if err := os.WriteFile(h.outputFile, svgBytes, 0o644); err != nil {
			return nil, fmt.Errorf("write svg file: %w", err)
		}
		// Print success message as in badges.bkp.sh
		// println("Badges saved to " + h.outputFile)
		// Note: Commented out to allow caller (e.g., gotest) to control output
	}
	// Silent when content unchanged - no need to log

	// Build the section args expected by SectionUpdate
	sectionContent := h.BadgeMarkdown()
	args := []string{h.sectionID, h.afterLine, sectionContent, h.readmeFile}
	return args, nil
}

// OutputFile returns the configured path for the output SVG file.
// This is the destination where the generated SVG image will be saved.
func (h *Badges) OutputFile() string {
	if h.err != nil {
		return ""
	}
	return h.outputFile
}

// ReadmeFile returns the configured path for the markdown file to be updated.
func (h *Badges) ReadmeFile() string {
	if h.err != nil {
		return ""
	}
	return h.readmeFile
}

// BadgeMarkdown generates the markdown snippet for embedding the badge image.
// The snippet is an HTML `<a>` tag containing an `<img>` tag, which is compatible
// with most markdown renderers.
//
// Example output:
//
//	<a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="..."></a>
func (h *Badges) BadgeMarkdown() string {
	if h.err != nil {
		return ""
	}

	svgFile := h.outputFile
	return fmt.Sprintf(`<a href="%s"><img src="%s" alt="Project Badges" title="%s"></a>`,
		svgFile, svgFile, h.badgesInfo)
}

// Err returns any error that occurred during the initialization or processing
// of the Badges. It's important to check this error before proceeding
// with badge generation.
func (h *Badges) Err() error {
	return h.err
}

// GoHandler returns the internal Go handler
func (h *Badges) GoHandler() *Go {
	return h.goH
}

func getGoVersion() string {
	out, err := RunCommand("go", "version")
	if err != nil {
		return "unknown"
	}
	parts := strings.Fields(out)
	if len(parts) >= 3 {
		return strings.TrimPrefix(parts[2], "go")
	}
	return "unknown"
}

func getBadgeColor(typ, value string) string {
	switch typ {
	case "license", "go":
		return "#007acc"
	case "tests":
		if value == "Passing" {
			return "#4c1"
		}
		return "#e05d44"
	case "coverage":
		// value is string like "85"
		val, _ := strconv.ParseFloat(value, 64)
		if val >= 80 {
			return "#4c1"
		} else if val >= 60 {
			return "#dfb317"
		} else if val > 0 {
			return "#fe7d37"
		}
		return "#e05d44"
	case "race":
		if value == "Clean" {
			return "#4c1"
		}
		return "#e05d44"
	case "vet":
		if value == "OK" {
			return "#4c1"
		}
		return "#e05d44"
	}
	return "#007acc"
}

func getModuleName(dir string) (string, error) {
	f, err := os.Open(filepath.Join(dir, "go.mod"))
	if err != nil {
		return "", err
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasPrefix(line, "module ") {
			return strings.TrimPrefix(line, "module "), nil
		}
	}
	return "", fmt.Errorf("module name not found in go.mod")
}

func checkFileExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

func updateBadges(readmeFile, licenseType, goVer, testStatus, coveragePercent, raceStatus, vetStatus string, quiet bool) error {
	// Colors
	licenseColor := getBadgeColor("license", licenseType)
	goColor := getBadgeColor("go", goVer)
	testColor := getBadgeColor("tests", testStatus)
	coverageColor := getBadgeColor("coverage", coveragePercent)
	raceColor := getBadgeColor("race", raceStatus)
	vetColor := getBadgeColor("vet", vetStatus)

	// Format: Label:Value:Color
	// Plus readmefile arg
	badgeArgs := []string{
		"readmefile:" + readmeFile,
		fmt.Sprintf("License:%s:%s", licenseType, licenseColor),
		fmt.Sprintf("Go:%s:%s", goVer, goColor),
		fmt.Sprintf("Tests:%s:%s", testStatus, testColor),
		fmt.Sprintf("Coverage:%s%%:%s", coveragePercent, coverageColor),
		fmt.Sprintf("Race:%s:%s", raceStatus, raceColor),
		fmt.Sprintf("Vet:%s:%s", vetStatus, vetColor),
	}

	sectionArgs, err := NewBadges(badgeArgs...).BuildBadges()
	if err != nil {
		return fmt.Errorf("error building badges: %w", err)
	}

	// Update README using mdgo
	if len(sectionArgs) >= 4 {
		// sectionArgs: sectionID, afterLine(unused), content, readmeFile
		sectionID := sectionArgs[0]
		content := sectionArgs[2]
		readmeFile := sectionArgs[3]

		// Use local MarkDown handler to update
		m := NewMarkDown(".", ".", func(name string, data []byte) error {
			return os.WriteFile(name, data, 0644)
		})
		m.InputPath(readmeFile, func(name string) ([]byte, error) {
			return os.ReadFile(name)
		})

		if err := m.UpdateSection(sectionID, content); err != nil {
			return fmt.Errorf("error updating README with markdown handler: %w", err)
		}

		if !quiet {
			fmt.Printf("Updated section %s in %s\n", sectionID, readmeFile)
		}
	}

	return nil
}
